name: lighthouse

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, ready_for_review]
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  lhci:
    name: Web Lighthouse (Perf/A11y)
    runs-on: ubuntu-latest
    # Draft PR에서는 실행하지 않고, main push 또는 Ready for Review 상태에서만 실행
    if: ${{ github.event_name != 'pull_request' || (github.event_name == 'pull_request' && github.event.pull_request.draft == false) }}
    permissions:
      contents: read
      pull-requests: write
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22.17.1
          cache: 'pnpm'
          cache-dependency-path: pnpm-lock.yaml

      - name: Install deps (web)
        run: pnpm -C apps/web install

      - name: Build (web)
        run: pnpm -C apps/web build

      - name: Start server
        env:
          NEXT_PUBLIC_RELAX_CSP: "1"
          NEXT_PUBLIC_ENABLE_SW: "0"
        run: pnpm -C apps/web start &

      - name: Wait for server
        run: |
          for i in {1..60}; do
            if curl -sSf http://localhost:3000 >/dev/null; then echo ready; exit 0; fi
            sleep 2
          done
          echo "server did not start" && exit 1

      - name: Lighthouse CI (mobile)
        id: lhci_mobile
        uses: treosh/lighthouse-ci-action@v12
        env:
          # Chrome stability in CI
          LHCI_COLLECT__SETTINGS__CHROME_FLAGS: "--no-sandbox --disable-dev-shm-usage"
          # Give a bit more time for First Contentful Paint to avoid NO_FCP flakes
          LHCI_COLLECT__SETTINGS__MAX_WAIT_FOR_FCP: 90000
          LHCI_COLLECT__SETTINGS__MAX_WAIT_FOR_LOAD: 90000
          # Relax CSP and disable SW during Lighthouse to avoid interference
          NEXT_PUBLIC_RELAX_CSP: "1"
          NEXT_PUBLIC_ENABLE_SW: "0"
        with:
          configPath: './lighthouserc.mobile.json'
          uploadArtifacts: true
          temporaryPublicStorage: true

      - name: Lighthouse CI (desktop)
        id: lhci_desktop
        uses: treosh/lighthouse-ci-action@v12
        env:
          LHCI_COLLECT__SETTINGS__CHROME_FLAGS: "--no-sandbox --disable-dev-shm-usage"
          LHCI_COLLECT__SETTINGS__MAX_WAIT_FOR_FCP: 90000
          LHCI_COLLECT__SETTINGS__MAX_WAIT_FOR_LOAD: 90000
          NEXT_PUBLIC_RELAX_CSP: "1"
          NEXT_PUBLIC_ENABLE_SW: "0"
        with:
          configPath: './lighthouserc.desktop.json'
          uploadArtifacts: true
          temporaryPublicStorage: true

      - name: Comment Lighthouse report links
        if: ${{ always() && github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        env:
          LHCI_LINKS_MOBILE:  ${{ steps.lhci_mobile.outputs.links }}
          LHCI_LINKS_DESKTOP: ${{ steps.lhci_desktop.outputs.links }}
          LHCI_ASSERT_MOBILE: ${{ steps.lhci_mobile.outputs.assertionResults }}
          LHCI_ASSERT_DESKTOP: ${{ steps.lhci_desktop.outputs.assertionResults }}
        with:
          script: |
            const core = require('@actions/core');
            function parseJson(input, fallback) {
              try { return input ? JSON.parse(input) : fallback; } catch { return fallback; }
            }

            const linksMobile  = parseJson(process.env.LHCI_LINKS_MOBILE, {});
            const linksDesktop = parseJson(process.env.LHCI_LINKS_DESKTOP, {});
            const links = { ...linksMobile, ...linksDesktop };

            const assertsMobile  = parseJson(process.env.LHCI_ASSERT_MOBILE, []);
            const assertsDesktop = parseJson(process.env.LHCI_ASSERT_DESKTOP, []);
            const asserts = [...assertsMobile, ...assertsDesktop];

            let body = '### Lighthouse CI\n';
            if (Object.keys(links).length) {
              body += Object.entries(links).map(([url, report]) => `- ${url} → ${report}`).join('\n') + '\n';
            } else {
              body += '_no links output_\n';
            }

            const failed = asserts.filter(a => a && a.level === 'error' && a.passed === false);
            if (failed.length) {
              body += '\n**Assertion failures**\n';
              body += failed.slice(0, 30).map(a => `- ${a.url || ''} · ${(a.auditTitle || a.name)} → expected ${a.operator} ${a.expected}, actual ${a.actual}`).join('\n');
            }

            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            } catch (e) {
              core.warning(`Skipping LH report comment: ${e.message}`);
            }
